// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_data_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_data_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_data_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_data_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_data_2eproto;
namespace mygame {
class Monster;
struct MonsterDefaultTypeInternal;
extern MonsterDefaultTypeInternal _Monster_default_instance_;
class Monsters;
struct MonstersDefaultTypeInternal;
extern MonstersDefaultTypeInternal _Monsters_default_instance_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Weapon;
struct WeaponDefaultTypeInternal;
extern WeaponDefaultTypeInternal _Weapon_default_instance_;
class person;
struct personDefaultTypeInternal;
extern personDefaultTypeInternal _person_default_instance_;
class persons;
struct personsDefaultTypeInternal;
extern personsDefaultTypeInternal _persons_default_instance_;
class rect32;
struct rect32DefaultTypeInternal;
extern rect32DefaultTypeInternal _rect32_default_instance_;
class rect32s;
struct rect32sDefaultTypeInternal;
extern rect32sDefaultTypeInternal _rect32s_default_instance_;
}  // namespace mygame
PROTOBUF_NAMESPACE_OPEN
template<> ::mygame::Monster* Arena::CreateMaybeMessage<::mygame::Monster>(Arena*);
template<> ::mygame::Monsters* Arena::CreateMaybeMessage<::mygame::Monsters>(Arena*);
template<> ::mygame::Vec3* Arena::CreateMaybeMessage<::mygame::Vec3>(Arena*);
template<> ::mygame::Weapon* Arena::CreateMaybeMessage<::mygame::Weapon>(Arena*);
template<> ::mygame::person* Arena::CreateMaybeMessage<::mygame::person>(Arena*);
template<> ::mygame::persons* Arena::CreateMaybeMessage<::mygame::persons>(Arena*);
template<> ::mygame::rect32* Arena::CreateMaybeMessage<::mygame::rect32>(Arena*);
template<> ::mygame::rect32s* Arena::CreateMaybeMessage<::mygame::rect32s>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mygame {

enum Monster_Color : int {
  Monster_Color_Red = 0,
  Monster_Color_Green = 1,
  Monster_Color_Blue = 2,
  Monster_Color_Monster_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Monster_Color_Monster_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Monster_Color_IsValid(int value);
constexpr Monster_Color Monster_Color_Color_MIN = Monster_Color_Red;
constexpr Monster_Color Monster_Color_Color_MAX = Monster_Color_Blue;
constexpr int Monster_Color_Color_ARRAYSIZE = Monster_Color_Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Monster_Color_descriptor();
template<typename T>
inline const std::string& Monster_Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Monster_Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Monster_Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Monster_Color_descriptor(), enum_t_value);
}
inline bool Monster_Color_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Monster_Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Monster_Color>(
    Monster_Color_descriptor(), name, value);
}
// ===================================================================

class Vec3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mygame.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() override;
  explicit PROTOBUF_CONSTEXPR Vec3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3(const Vec3& from);
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vec3& from) {
    Vec3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mygame.Vec3";
  }
  protected:
  explicit Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:mygame.Vec3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Weapon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mygame.Weapon) */ {
 public:
  inline Weapon() : Weapon(nullptr) {}
  ~Weapon() override;
  explicit PROTOBUF_CONSTEXPR Weapon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Weapon(const Weapon& from);
  Weapon(Weapon&& from) noexcept
    : Weapon() {
    *this = ::std::move(from);
  }

  inline Weapon& operator=(const Weapon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Weapon& operator=(Weapon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Weapon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Weapon* internal_default_instance() {
    return reinterpret_cast<const Weapon*>(
               &_Weapon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Weapon& a, Weapon& b) {
    a.Swap(&b);
  }
  inline void Swap(Weapon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Weapon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Weapon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Weapon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Weapon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Weapon& from) {
    Weapon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Weapon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mygame.Weapon";
  }
  protected:
  explicit Weapon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDamageFieldNumber = 2,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 damage = 2;
  void clear_damage();
  int32_t damage() const;
  void set_damage(int32_t value);
  private:
  int32_t _internal_damage() const;
  void _internal_set_damage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mygame.Weapon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Monster final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mygame.Monster) */ {
 public:
  inline Monster() : Monster(nullptr) {}
  ~Monster() override;
  explicit PROTOBUF_CONSTEXPR Monster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Monster(const Monster& from);
  Monster(Monster&& from) noexcept
    : Monster() {
    *this = ::std::move(from);
  }

  inline Monster& operator=(const Monster& from) {
    CopyFrom(from);
    return *this;
  }
  inline Monster& operator=(Monster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Monster& default_instance() {
    return *internal_default_instance();
  }
  static inline const Monster* internal_default_instance() {
    return reinterpret_cast<const Monster*>(
               &_Monster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Monster& a, Monster& b) {
    a.Swap(&b);
  }
  inline void Swap(Monster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Monster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Monster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Monster>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Monster& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Monster& from) {
    Monster::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Monster* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mygame.Monster";
  }
  protected:
  explicit Monster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Monster_Color Color;
  static constexpr Color Red =
    Monster_Color_Red;
  static constexpr Color Green =
    Monster_Color_Green;
  static constexpr Color Blue =
    Monster_Color_Blue;
  static inline bool Color_IsValid(int value) {
    return Monster_Color_IsValid(value);
  }
  static constexpr Color Color_MIN =
    Monster_Color_Color_MIN;
  static constexpr Color Color_MAX =
    Monster_Color_Color_MAX;
  static constexpr int Color_ARRAYSIZE =
    Monster_Color_Color_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Color_descriptor() {
    return Monster_Color_descriptor();
  }
  template<typename T>
  static inline const std::string& Color_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Color>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Color_Name.");
    return Monster_Color_Name(enum_t_value);
  }
  static inline bool Color_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Color* value) {
    return Monster_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponsFieldNumber = 7,
    kPathFieldNumber = 9,
    kNameFieldNumber = 4,
    kInventoryFieldNumber = 5,
    kPosFieldNumber = 1,
    kEquippedFieldNumber = 8,
    kManaFieldNumber = 2,
    kHpFieldNumber = 3,
    kColorFieldNumber = 6,
  };
  // repeated .mygame.Weapon weapons = 7;
  int weapons_size() const;
  private:
  int _internal_weapons_size() const;
  public:
  void clear_weapons();
  ::mygame::Weapon* mutable_weapons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Weapon >*
      mutable_weapons();
  private:
  const ::mygame::Weapon& _internal_weapons(int index) const;
  ::mygame::Weapon* _internal_add_weapons();
  public:
  const ::mygame::Weapon& weapons(int index) const;
  ::mygame::Weapon* add_weapons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Weapon >&
      weapons() const;

  // repeated .mygame.Vec3 path = 9;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  ::mygame::Vec3* mutable_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Vec3 >*
      mutable_path();
  private:
  const ::mygame::Vec3& _internal_path(int index) const;
  ::mygame::Vec3* _internal_add_path();
  public:
  const ::mygame::Vec3& path(int index) const;
  ::mygame::Vec3* add_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Vec3 >&
      path() const;

  // bytes name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes inventory = 5;
  void clear_inventory();
  const std::string& inventory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_inventory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_inventory();
  PROTOBUF_NODISCARD std::string* release_inventory();
  void set_allocated_inventory(std::string* inventory);
  private:
  const std::string& _internal_inventory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inventory(const std::string& value);
  std::string* _internal_mutable_inventory();
  public:

  // .mygame.Vec3 pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::mygame::Vec3& pos() const;
  PROTOBUF_NODISCARD ::mygame::Vec3* release_pos();
  ::mygame::Vec3* mutable_pos();
  void set_allocated_pos(::mygame::Vec3* pos);
  private:
  const ::mygame::Vec3& _internal_pos() const;
  ::mygame::Vec3* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::mygame::Vec3* pos);
  ::mygame::Vec3* unsafe_arena_release_pos();

  // .mygame.Weapon equipped = 8;
  bool has_equipped() const;
  private:
  bool _internal_has_equipped() const;
  public:
  void clear_equipped();
  const ::mygame::Weapon& equipped() const;
  PROTOBUF_NODISCARD ::mygame::Weapon* release_equipped();
  ::mygame::Weapon* mutable_equipped();
  void set_allocated_equipped(::mygame::Weapon* equipped);
  private:
  const ::mygame::Weapon& _internal_equipped() const;
  ::mygame::Weapon* _internal_mutable_equipped();
  public:
  void unsafe_arena_set_allocated_equipped(
      ::mygame::Weapon* equipped);
  ::mygame::Weapon* unsafe_arena_release_equipped();

  // int32 mana = 2;
  void clear_mana();
  int32_t mana() const;
  void set_mana(int32_t value);
  private:
  int32_t _internal_mana() const;
  void _internal_set_mana(int32_t value);
  public:

  // int32 hp = 3;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // .mygame.Monster.Color color = 6;
  void clear_color();
  ::mygame::Monster_Color color() const;
  void set_color(::mygame::Monster_Color value);
  private:
  ::mygame::Monster_Color _internal_color() const;
  void _internal_set_color(::mygame::Monster_Color value);
  public:

  // @@protoc_insertion_point(class_scope:mygame.Monster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Weapon > weapons_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Vec3 > path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inventory_;
    ::mygame::Vec3* pos_;
    ::mygame::Weapon* equipped_;
    int32_t mana_;
    int32_t hp_;
    int color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Monsters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mygame.Monsters) */ {
 public:
  inline Monsters() : Monsters(nullptr) {}
  ~Monsters() override;
  explicit PROTOBUF_CONSTEXPR Monsters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Monsters(const Monsters& from);
  Monsters(Monsters&& from) noexcept
    : Monsters() {
    *this = ::std::move(from);
  }

  inline Monsters& operator=(const Monsters& from) {
    CopyFrom(from);
    return *this;
  }
  inline Monsters& operator=(Monsters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Monsters& default_instance() {
    return *internal_default_instance();
  }
  static inline const Monsters* internal_default_instance() {
    return reinterpret_cast<const Monsters*>(
               &_Monsters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Monsters& a, Monsters& b) {
    a.Swap(&b);
  }
  inline void Swap(Monsters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Monsters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Monsters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Monsters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Monsters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Monsters& from) {
    Monsters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Monsters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mygame.Monsters";
  }
  protected:
  explicit Monsters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonstersFieldNumber = 1,
  };
  // repeated .mygame.Monster monsters = 1;
  int monsters_size() const;
  private:
  int _internal_monsters_size() const;
  public:
  void clear_monsters();
  ::mygame::Monster* mutable_monsters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Monster >*
      mutable_monsters();
  private:
  const ::mygame::Monster& _internal_monsters(int index) const;
  ::mygame::Monster* _internal_add_monsters();
  public:
  const ::mygame::Monster& monsters(int index) const;
  ::mygame::Monster* add_monsters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Monster >&
      monsters() const;

  // @@protoc_insertion_point(class_scope:mygame.Monsters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Monster > monsters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class rect32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mygame.rect32) */ {
 public:
  inline rect32() : rect32(nullptr) {}
  ~rect32() override;
  explicit PROTOBUF_CONSTEXPR rect32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  rect32(const rect32& from);
  rect32(rect32&& from) noexcept
    : rect32() {
    *this = ::std::move(from);
  }

  inline rect32& operator=(const rect32& from) {
    CopyFrom(from);
    return *this;
  }
  inline rect32& operator=(rect32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const rect32& default_instance() {
    return *internal_default_instance();
  }
  static inline const rect32* internal_default_instance() {
    return reinterpret_cast<const rect32*>(
               &_rect32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(rect32& a, rect32& b) {
    a.Swap(&b);
  }
  inline void Swap(rect32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rect32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  rect32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<rect32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const rect32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const rect32& from) {
    rect32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rect32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mygame.rect32";
  }
  protected:
  explicit rect32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 width = 3;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 4;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mygame.rect32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    int32_t width_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class rect32s final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mygame.rect32s) */ {
 public:
  inline rect32s() : rect32s(nullptr) {}
  ~rect32s() override;
  explicit PROTOBUF_CONSTEXPR rect32s(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  rect32s(const rect32s& from);
  rect32s(rect32s&& from) noexcept
    : rect32s() {
    *this = ::std::move(from);
  }

  inline rect32s& operator=(const rect32s& from) {
    CopyFrom(from);
    return *this;
  }
  inline rect32s& operator=(rect32s&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const rect32s& default_instance() {
    return *internal_default_instance();
  }
  static inline const rect32s* internal_default_instance() {
    return reinterpret_cast<const rect32s*>(
               &_rect32s_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(rect32s& a, rect32s& b) {
    a.Swap(&b);
  }
  inline void Swap(rect32s* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rect32s* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  rect32s* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<rect32s>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const rect32s& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const rect32s& from) {
    rect32s::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rect32s* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mygame.rect32s";
  }
  protected:
  explicit rect32s(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRect32ListFieldNumber = 1,
  };
  // repeated .mygame.rect32 rect32_list = 1;
  int rect32_list_size() const;
  private:
  int _internal_rect32_list_size() const;
  public:
  void clear_rect32_list();
  ::mygame::rect32* mutable_rect32_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::rect32 >*
      mutable_rect32_list();
  private:
  const ::mygame::rect32& _internal_rect32_list(int index) const;
  ::mygame::rect32* _internal_add_rect32_list();
  public:
  const ::mygame::rect32& rect32_list(int index) const;
  ::mygame::rect32* add_rect32_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::rect32 >&
      rect32_list() const;

  // @@protoc_insertion_point(class_scope:mygame.rect32s)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::rect32 > rect32_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class person final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mygame.person) */ {
 public:
  inline person() : person(nullptr) {}
  ~person() override;
  explicit PROTOBUF_CONSTEXPR person(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  person(const person& from);
  person(person&& from) noexcept
    : person() {
    *this = ::std::move(from);
  }

  inline person& operator=(const person& from) {
    CopyFrom(from);
    return *this;
  }
  inline person& operator=(person&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const person& default_instance() {
    return *internal_default_instance();
  }
  static inline const person* internal_default_instance() {
    return reinterpret_cast<const person*>(
               &_person_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(person& a, person& b) {
    a.Swap(&b);
  }
  inline void Swap(person* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(person* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  person* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<person>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const person& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const person& from) {
    person::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(person* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mygame.person";
  }
  protected:
  explicit person(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kAgeFieldNumber = 3,
    kSalaryFieldNumber = 4,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 age = 3;
  void clear_age();
  int32_t age() const;
  void set_age(int32_t value);
  private:
  int32_t _internal_age() const;
  void _internal_set_age(int32_t value);
  public:

  // double salary = 4;
  void clear_salary();
  double salary() const;
  void set_salary(double value);
  private:
  double _internal_salary() const;
  void _internal_set_salary(double value);
  public:

  // @@protoc_insertion_point(class_scope:mygame.person)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t id_;
    int32_t age_;
    double salary_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class persons final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mygame.persons) */ {
 public:
  inline persons() : persons(nullptr) {}
  ~persons() override;
  explicit PROTOBUF_CONSTEXPR persons(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  persons(const persons& from);
  persons(persons&& from) noexcept
    : persons() {
    *this = ::std::move(from);
  }

  inline persons& operator=(const persons& from) {
    CopyFrom(from);
    return *this;
  }
  inline persons& operator=(persons&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const persons& default_instance() {
    return *internal_default_instance();
  }
  static inline const persons* internal_default_instance() {
    return reinterpret_cast<const persons*>(
               &_persons_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(persons& a, persons& b) {
    a.Swap(&b);
  }
  inline void Swap(persons* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(persons* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  persons* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<persons>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const persons& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const persons& from) {
    persons::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(persons* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mygame.persons";
  }
  protected:
  explicit persons(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPersonListFieldNumber = 1,
  };
  // repeated .mygame.person person_list = 1;
  int person_list_size() const;
  private:
  int _internal_person_list_size() const;
  public:
  void clear_person_list();
  ::mygame::person* mutable_person_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::person >*
      mutable_person_list();
  private:
  const ::mygame::person& _internal_person_list(int index) const;
  ::mygame::person* _internal_add_person_list();
  public:
  const ::mygame::person& person_list(int index) const;
  ::mygame::person* add_person_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::person >&
      person_list() const;

  // @@protoc_insertion_point(class_scope:mygame.persons)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::person > person_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec3

// float x = 1;
inline void Vec3::clear_x() {
  _impl_.x_ = 0;
}
inline float Vec3::_internal_x() const {
  return _impl_.x_;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:mygame.Vec3.x)
  return _internal_x();
}
inline void Vec3::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mygame.Vec3.x)
}

// float y = 2;
inline void Vec3::clear_y() {
  _impl_.y_ = 0;
}
inline float Vec3::_internal_y() const {
  return _impl_.y_;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:mygame.Vec3.y)
  return _internal_y();
}
inline void Vec3::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mygame.Vec3.y)
}

// float z = 3;
inline void Vec3::clear_z() {
  _impl_.z_ = 0;
}
inline float Vec3::_internal_z() const {
  return _impl_.z_;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:mygame.Vec3.z)
  return _internal_z();
}
inline void Vec3::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mygame.Vec3.z)
}

// -------------------------------------------------------------------

// Weapon

// bytes name = 1;
inline void Weapon::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Weapon::name() const {
  // @@protoc_insertion_point(field_get:mygame.Weapon.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Weapon::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mygame.Weapon.name)
}
inline std::string* Weapon::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mygame.Weapon.name)
  return _s;
}
inline const std::string& Weapon::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Weapon::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Weapon::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Weapon::release_name() {
  // @@protoc_insertion_point(field_release:mygame.Weapon.name)
  return _impl_.name_.Release();
}
inline void Weapon::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mygame.Weapon.name)
}

// int32 damage = 2;
inline void Weapon::clear_damage() {
  _impl_.damage_ = 0;
}
inline int32_t Weapon::_internal_damage() const {
  return _impl_.damage_;
}
inline int32_t Weapon::damage() const {
  // @@protoc_insertion_point(field_get:mygame.Weapon.damage)
  return _internal_damage();
}
inline void Weapon::_internal_set_damage(int32_t value) {
  
  _impl_.damage_ = value;
}
inline void Weapon::set_damage(int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:mygame.Weapon.damage)
}

// -------------------------------------------------------------------

// Monster

// .mygame.Vec3 pos = 1;
inline bool Monster::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Monster::has_pos() const {
  return _internal_has_pos();
}
inline void Monster::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::mygame::Vec3& Monster::_internal_pos() const {
  const ::mygame::Vec3* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::mygame::Vec3&>(
      ::mygame::_Vec3_default_instance_);
}
inline const ::mygame::Vec3& Monster::pos() const {
  // @@protoc_insertion_point(field_get:mygame.Monster.pos)
  return _internal_pos();
}
inline void Monster::unsafe_arena_set_allocated_pos(
    ::mygame::Vec3* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mygame.Monster.pos)
}
inline ::mygame::Vec3* Monster::release_pos() {
  
  ::mygame::Vec3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mygame::Vec3* Monster::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:mygame.Monster.pos)
  
  ::mygame::Vec3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::mygame::Vec3* Monster::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::mygame::Vec3>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::mygame::Vec3* Monster::mutable_pos() {
  ::mygame::Vec3* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:mygame.Monster.pos)
  return _msg;
}
inline void Monster::set_allocated_pos(::mygame::Vec3* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:mygame.Monster.pos)
}

// int32 mana = 2;
inline void Monster::clear_mana() {
  _impl_.mana_ = 0;
}
inline int32_t Monster::_internal_mana() const {
  return _impl_.mana_;
}
inline int32_t Monster::mana() const {
  // @@protoc_insertion_point(field_get:mygame.Monster.mana)
  return _internal_mana();
}
inline void Monster::_internal_set_mana(int32_t value) {
  
  _impl_.mana_ = value;
}
inline void Monster::set_mana(int32_t value) {
  _internal_set_mana(value);
  // @@protoc_insertion_point(field_set:mygame.Monster.mana)
}

// int32 hp = 3;
inline void Monster::clear_hp() {
  _impl_.hp_ = 0;
}
inline int32_t Monster::_internal_hp() const {
  return _impl_.hp_;
}
inline int32_t Monster::hp() const {
  // @@protoc_insertion_point(field_get:mygame.Monster.hp)
  return _internal_hp();
}
inline void Monster::_internal_set_hp(int32_t value) {
  
  _impl_.hp_ = value;
}
inline void Monster::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:mygame.Monster.hp)
}

// bytes name = 4;
inline void Monster::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Monster::name() const {
  // @@protoc_insertion_point(field_get:mygame.Monster.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monster::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mygame.Monster.name)
}
inline std::string* Monster::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mygame.Monster.name)
  return _s;
}
inline const std::string& Monster::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Monster::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Monster::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Monster::release_name() {
  // @@protoc_insertion_point(field_release:mygame.Monster.name)
  return _impl_.name_.Release();
}
inline void Monster::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mygame.Monster.name)
}

// bytes inventory = 5;
inline void Monster::clear_inventory() {
  _impl_.inventory_.ClearToEmpty();
}
inline const std::string& Monster::inventory() const {
  // @@protoc_insertion_point(field_get:mygame.Monster.inventory)
  return _internal_inventory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monster::set_inventory(ArgT0&& arg0, ArgT... args) {
 
 _impl_.inventory_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mygame.Monster.inventory)
}
inline std::string* Monster::mutable_inventory() {
  std::string* _s = _internal_mutable_inventory();
  // @@protoc_insertion_point(field_mutable:mygame.Monster.inventory)
  return _s;
}
inline const std::string& Monster::_internal_inventory() const {
  return _impl_.inventory_.Get();
}
inline void Monster::_internal_set_inventory(const std::string& value) {
  
  _impl_.inventory_.Set(value, GetArenaForAllocation());
}
inline std::string* Monster::_internal_mutable_inventory() {
  
  return _impl_.inventory_.Mutable(GetArenaForAllocation());
}
inline std::string* Monster::release_inventory() {
  // @@protoc_insertion_point(field_release:mygame.Monster.inventory)
  return _impl_.inventory_.Release();
}
inline void Monster::set_allocated_inventory(std::string* inventory) {
  if (inventory != nullptr) {
    
  } else {
    
  }
  _impl_.inventory_.SetAllocated(inventory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.inventory_.IsDefault()) {
    _impl_.inventory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mygame.Monster.inventory)
}

// .mygame.Monster.Color color = 6;
inline void Monster::clear_color() {
  _impl_.color_ = 0;
}
inline ::mygame::Monster_Color Monster::_internal_color() const {
  return static_cast< ::mygame::Monster_Color >(_impl_.color_);
}
inline ::mygame::Monster_Color Monster::color() const {
  // @@protoc_insertion_point(field_get:mygame.Monster.color)
  return _internal_color();
}
inline void Monster::_internal_set_color(::mygame::Monster_Color value) {
  
  _impl_.color_ = value;
}
inline void Monster::set_color(::mygame::Monster_Color value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:mygame.Monster.color)
}

// repeated .mygame.Weapon weapons = 7;
inline int Monster::_internal_weapons_size() const {
  return _impl_.weapons_.size();
}
inline int Monster::weapons_size() const {
  return _internal_weapons_size();
}
inline void Monster::clear_weapons() {
  _impl_.weapons_.Clear();
}
inline ::mygame::Weapon* Monster::mutable_weapons(int index) {
  // @@protoc_insertion_point(field_mutable:mygame.Monster.weapons)
  return _impl_.weapons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Weapon >*
Monster::mutable_weapons() {
  // @@protoc_insertion_point(field_mutable_list:mygame.Monster.weapons)
  return &_impl_.weapons_;
}
inline const ::mygame::Weapon& Monster::_internal_weapons(int index) const {
  return _impl_.weapons_.Get(index);
}
inline const ::mygame::Weapon& Monster::weapons(int index) const {
  // @@protoc_insertion_point(field_get:mygame.Monster.weapons)
  return _internal_weapons(index);
}
inline ::mygame::Weapon* Monster::_internal_add_weapons() {
  return _impl_.weapons_.Add();
}
inline ::mygame::Weapon* Monster::add_weapons() {
  ::mygame::Weapon* _add = _internal_add_weapons();
  // @@protoc_insertion_point(field_add:mygame.Monster.weapons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Weapon >&
Monster::weapons() const {
  // @@protoc_insertion_point(field_list:mygame.Monster.weapons)
  return _impl_.weapons_;
}

// .mygame.Weapon equipped = 8;
inline bool Monster::_internal_has_equipped() const {
  return this != internal_default_instance() && _impl_.equipped_ != nullptr;
}
inline bool Monster::has_equipped() const {
  return _internal_has_equipped();
}
inline void Monster::clear_equipped() {
  if (GetArenaForAllocation() == nullptr && _impl_.equipped_ != nullptr) {
    delete _impl_.equipped_;
  }
  _impl_.equipped_ = nullptr;
}
inline const ::mygame::Weapon& Monster::_internal_equipped() const {
  const ::mygame::Weapon* p = _impl_.equipped_;
  return p != nullptr ? *p : reinterpret_cast<const ::mygame::Weapon&>(
      ::mygame::_Weapon_default_instance_);
}
inline const ::mygame::Weapon& Monster::equipped() const {
  // @@protoc_insertion_point(field_get:mygame.Monster.equipped)
  return _internal_equipped();
}
inline void Monster::unsafe_arena_set_allocated_equipped(
    ::mygame::Weapon* equipped) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equipped_);
  }
  _impl_.equipped_ = equipped;
  if (equipped) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mygame.Monster.equipped)
}
inline ::mygame::Weapon* Monster::release_equipped() {
  
  ::mygame::Weapon* temp = _impl_.equipped_;
  _impl_.equipped_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mygame::Weapon* Monster::unsafe_arena_release_equipped() {
  // @@protoc_insertion_point(field_release:mygame.Monster.equipped)
  
  ::mygame::Weapon* temp = _impl_.equipped_;
  _impl_.equipped_ = nullptr;
  return temp;
}
inline ::mygame::Weapon* Monster::_internal_mutable_equipped() {
  
  if (_impl_.equipped_ == nullptr) {
    auto* p = CreateMaybeMessage<::mygame::Weapon>(GetArenaForAllocation());
    _impl_.equipped_ = p;
  }
  return _impl_.equipped_;
}
inline ::mygame::Weapon* Monster::mutable_equipped() {
  ::mygame::Weapon* _msg = _internal_mutable_equipped();
  // @@protoc_insertion_point(field_mutable:mygame.Monster.equipped)
  return _msg;
}
inline void Monster::set_allocated_equipped(::mygame::Weapon* equipped) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.equipped_;
  }
  if (equipped) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(equipped);
    if (message_arena != submessage_arena) {
      equipped = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equipped, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.equipped_ = equipped;
  // @@protoc_insertion_point(field_set_allocated:mygame.Monster.equipped)
}

// repeated .mygame.Vec3 path = 9;
inline int Monster::_internal_path_size() const {
  return _impl_.path_.size();
}
inline int Monster::path_size() const {
  return _internal_path_size();
}
inline void Monster::clear_path() {
  _impl_.path_.Clear();
}
inline ::mygame::Vec3* Monster::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:mygame.Monster.path)
  return _impl_.path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Vec3 >*
Monster::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:mygame.Monster.path)
  return &_impl_.path_;
}
inline const ::mygame::Vec3& Monster::_internal_path(int index) const {
  return _impl_.path_.Get(index);
}
inline const ::mygame::Vec3& Monster::path(int index) const {
  // @@protoc_insertion_point(field_get:mygame.Monster.path)
  return _internal_path(index);
}
inline ::mygame::Vec3* Monster::_internal_add_path() {
  return _impl_.path_.Add();
}
inline ::mygame::Vec3* Monster::add_path() {
  ::mygame::Vec3* _add = _internal_add_path();
  // @@protoc_insertion_point(field_add:mygame.Monster.path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Vec3 >&
Monster::path() const {
  // @@protoc_insertion_point(field_list:mygame.Monster.path)
  return _impl_.path_;
}

// -------------------------------------------------------------------

// Monsters

// repeated .mygame.Monster monsters = 1;
inline int Monsters::_internal_monsters_size() const {
  return _impl_.monsters_.size();
}
inline int Monsters::monsters_size() const {
  return _internal_monsters_size();
}
inline void Monsters::clear_monsters() {
  _impl_.monsters_.Clear();
}
inline ::mygame::Monster* Monsters::mutable_monsters(int index) {
  // @@protoc_insertion_point(field_mutable:mygame.Monsters.monsters)
  return _impl_.monsters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Monster >*
Monsters::mutable_monsters() {
  // @@protoc_insertion_point(field_mutable_list:mygame.Monsters.monsters)
  return &_impl_.monsters_;
}
inline const ::mygame::Monster& Monsters::_internal_monsters(int index) const {
  return _impl_.monsters_.Get(index);
}
inline const ::mygame::Monster& Monsters::monsters(int index) const {
  // @@protoc_insertion_point(field_get:mygame.Monsters.monsters)
  return _internal_monsters(index);
}
inline ::mygame::Monster* Monsters::_internal_add_monsters() {
  return _impl_.monsters_.Add();
}
inline ::mygame::Monster* Monsters::add_monsters() {
  ::mygame::Monster* _add = _internal_add_monsters();
  // @@protoc_insertion_point(field_add:mygame.Monsters.monsters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::Monster >&
Monsters::monsters() const {
  // @@protoc_insertion_point(field_list:mygame.Monsters.monsters)
  return _impl_.monsters_;
}

// -------------------------------------------------------------------

// rect32

// int32 x = 1;
inline void rect32::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t rect32::_internal_x() const {
  return _impl_.x_;
}
inline int32_t rect32::x() const {
  // @@protoc_insertion_point(field_get:mygame.rect32.x)
  return _internal_x();
}
inline void rect32::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void rect32::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mygame.rect32.x)
}

// int32 y = 2;
inline void rect32::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t rect32::_internal_y() const {
  return _impl_.y_;
}
inline int32_t rect32::y() const {
  // @@protoc_insertion_point(field_get:mygame.rect32.y)
  return _internal_y();
}
inline void rect32::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void rect32::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mygame.rect32.y)
}

// int32 width = 3;
inline void rect32::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t rect32::_internal_width() const {
  return _impl_.width_;
}
inline int32_t rect32::width() const {
  // @@protoc_insertion_point(field_get:mygame.rect32.width)
  return _internal_width();
}
inline void rect32::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void rect32::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:mygame.rect32.width)
}

// int32 height = 4;
inline void rect32::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t rect32::_internal_height() const {
  return _impl_.height_;
}
inline int32_t rect32::height() const {
  // @@protoc_insertion_point(field_get:mygame.rect32.height)
  return _internal_height();
}
inline void rect32::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void rect32::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:mygame.rect32.height)
}

// -------------------------------------------------------------------

// rect32s

// repeated .mygame.rect32 rect32_list = 1;
inline int rect32s::_internal_rect32_list_size() const {
  return _impl_.rect32_list_.size();
}
inline int rect32s::rect32_list_size() const {
  return _internal_rect32_list_size();
}
inline void rect32s::clear_rect32_list() {
  _impl_.rect32_list_.Clear();
}
inline ::mygame::rect32* rect32s::mutable_rect32_list(int index) {
  // @@protoc_insertion_point(field_mutable:mygame.rect32s.rect32_list)
  return _impl_.rect32_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::rect32 >*
rect32s::mutable_rect32_list() {
  // @@protoc_insertion_point(field_mutable_list:mygame.rect32s.rect32_list)
  return &_impl_.rect32_list_;
}
inline const ::mygame::rect32& rect32s::_internal_rect32_list(int index) const {
  return _impl_.rect32_list_.Get(index);
}
inline const ::mygame::rect32& rect32s::rect32_list(int index) const {
  // @@protoc_insertion_point(field_get:mygame.rect32s.rect32_list)
  return _internal_rect32_list(index);
}
inline ::mygame::rect32* rect32s::_internal_add_rect32_list() {
  return _impl_.rect32_list_.Add();
}
inline ::mygame::rect32* rect32s::add_rect32_list() {
  ::mygame::rect32* _add = _internal_add_rect32_list();
  // @@protoc_insertion_point(field_add:mygame.rect32s.rect32_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::rect32 >&
rect32s::rect32_list() const {
  // @@protoc_insertion_point(field_list:mygame.rect32s.rect32_list)
  return _impl_.rect32_list_;
}

// -------------------------------------------------------------------

// person

// int32 id = 1;
inline void person::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t person::_internal_id() const {
  return _impl_.id_;
}
inline int32_t person::id() const {
  // @@protoc_insertion_point(field_get:mygame.person.id)
  return _internal_id();
}
inline void person::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void person::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mygame.person.id)
}

// bytes name = 2;
inline void person::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& person::name() const {
  // @@protoc_insertion_point(field_get:mygame.person.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void person::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mygame.person.name)
}
inline std::string* person::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mygame.person.name)
  return _s;
}
inline const std::string& person::_internal_name() const {
  return _impl_.name_.Get();
}
inline void person::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* person::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* person::release_name() {
  // @@protoc_insertion_point(field_release:mygame.person.name)
  return _impl_.name_.Release();
}
inline void person::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mygame.person.name)
}

// int32 age = 3;
inline void person::clear_age() {
  _impl_.age_ = 0;
}
inline int32_t person::_internal_age() const {
  return _impl_.age_;
}
inline int32_t person::age() const {
  // @@protoc_insertion_point(field_get:mygame.person.age)
  return _internal_age();
}
inline void person::_internal_set_age(int32_t value) {
  
  _impl_.age_ = value;
}
inline void person::set_age(int32_t value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:mygame.person.age)
}

// double salary = 4;
inline void person::clear_salary() {
  _impl_.salary_ = 0;
}
inline double person::_internal_salary() const {
  return _impl_.salary_;
}
inline double person::salary() const {
  // @@protoc_insertion_point(field_get:mygame.person.salary)
  return _internal_salary();
}
inline void person::_internal_set_salary(double value) {
  
  _impl_.salary_ = value;
}
inline void person::set_salary(double value) {
  _internal_set_salary(value);
  // @@protoc_insertion_point(field_set:mygame.person.salary)
}

// -------------------------------------------------------------------

// persons

// repeated .mygame.person person_list = 1;
inline int persons::_internal_person_list_size() const {
  return _impl_.person_list_.size();
}
inline int persons::person_list_size() const {
  return _internal_person_list_size();
}
inline void persons::clear_person_list() {
  _impl_.person_list_.Clear();
}
inline ::mygame::person* persons::mutable_person_list(int index) {
  // @@protoc_insertion_point(field_mutable:mygame.persons.person_list)
  return _impl_.person_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::person >*
persons::mutable_person_list() {
  // @@protoc_insertion_point(field_mutable_list:mygame.persons.person_list)
  return &_impl_.person_list_;
}
inline const ::mygame::person& persons::_internal_person_list(int index) const {
  return _impl_.person_list_.Get(index);
}
inline const ::mygame::person& persons::person_list(int index) const {
  // @@protoc_insertion_point(field_get:mygame.persons.person_list)
  return _internal_person_list(index);
}
inline ::mygame::person* persons::_internal_add_person_list() {
  return _impl_.person_list_.Add();
}
inline ::mygame::person* persons::add_person_list() {
  ::mygame::person* _add = _internal_add_person_list();
  // @@protoc_insertion_point(field_add:mygame.persons.person_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mygame::person >&
persons::person_list() const {
  // @@protoc_insertion_point(field_list:mygame.persons.person_list)
  return _impl_.person_list_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mygame

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mygame::Monster_Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mygame::Monster_Color>() {
  return ::mygame::Monster_Color_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_data_2eproto
